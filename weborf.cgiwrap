#!/usr/bin/python
'''
Weborf
Copyright (C) 2008  Salvo "LtWorf" Tomaselli

Weborf is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

@author Salvo "LtWorf" Tomaselli <tiposchi@tiscali.it>
'''

import sys
import py_compile
import os
import socket
import base64
import csv
import time

def getVal(dic,key):
    '''Returns the value dic[key] or None if the key doesn't exist'''
    try:
        return dic[key]
    except:
        return ""

#Loading configuration from file or setting default
try:
    execfile("/etc/weborf/cgiwrapper.conf")
except:
    pass


#env vars for the script
env={}


#Sets HEADER variables
_HEADER={}
fields = sys.argv[3].split("\r\n")

env['SERVER_PROTOCOL']=fields.pop(0)

fields.remove("")
for i in fields:
    v=i.split(": ",1)
    _HEADER[v[0]]=v[1]
    
'''          meta-variable-name =  |  |
                           "PATH_INFO" | "PATH_TRANSLATED" |
                           "REMOTE_HOST" | "REMOTE_IDENT" |
                           | scheme |
                           protocol-var-name | extension-var-name
      protocol-var-name  = ( protocol | scheme ) "_" var-name
      scheme             = alpha *( alpha | digit | "+" | "-" | "." )
      var-name           = token
      extension-var-name = token'''

env['PATH']=os.getenv("PATH")
env['REQUEST_METHOD']=sys.argv[4] #GET | POST, from command line
env["SERVER_NAME"]=getVal(_HEADER,'Host') #Name of the server from the host field in the header
env['GATEWAY_INTERFACE']="CGI/1.1" #CGI version
env['SERVER_SOFTWARE']=os.getenv('SERVER_SOFTWARE') #Weborf version

# All header's fields
for i in _HEADER:
    env["HTTP_"+i.upper().replace("-","_")]=_HEADER[i]

env['REDIRECT_STATUS']="Ciao"#Mah.. i'll never understand php, this env var is needed
env['SCRIPT_FILENAME']=sys.argv[1] #This var is needed as well or php say no input file...


#Request URI with or without a query
if len( sys.argv[2])!=0:
    env['REQUEST_URI']=sys.argv[1][len(sys.argv[6]):]+"?" + sys.argv[2]
else:
    env['REQUEST_URI']=sys.argv[1][len(sys.argv[6]):]

env['SCRIPT_NAME']=sys.argv[1][len(sys.argv[6]):]
env["QUERY_STRING"]=sys.argv[2] #Query after ?
env['REMOTE_ADDR']=sys.argv[5] #Client's address

#Deconding auth field
v=getVal(_HEADER,'Authorization')
if v!="":
    q=v.split(" ")
    env['AUTH_TYPE']=q[0]
    auth=base64.b64decode(q[1]).split(":",1)
    env['REMOTE_USER']=auth[0]

#Changing dir to script's one
for i in range(len(sys.argv[1])-1,-1,-1):
    if sys.argv[1][i]==os.sep:
        os.chdir(sys.argv[1][0:i])
        break

cmd_line=["-f",sys.argv[1]]

#Sets GET variables
if len(sys.argv[2])!=0:
    for i in sys.argv[2].split("&"):
        cmd_line.append(i)


o_pipe=os.pipe() #Output for child process
i_pipe=os.pipe() #Input for child process

#Sets POST variables
if getVal(_HEADER,"Content-Length")!="":
    env['CONTENT_LENGTH']=getVal(_HEADER,"Content-Length").strip()
    post=os.read(sys.stdin.fileno(),int(env['CONTENT_LENGTH']))
    env['CONTENT_TYPE']=_HEADER['Content-Type']
    os.write(i_pipe[1],post)

pid=os.fork()
out=""
if pid==0: #Child process
    stdin=sys.stdin.fileno()
    stdout=sys.stdout.fileno()
    
    #Redirecting stdin to i_pipe
    os.close(stdin)
    os.close(i_pipe[1])
    os.dup(i_pipe[0])
    
    #Redirecting stdout to o_pipe
    os.close(stdout)
    os.close(o_pipe[0])
    os.dup(o_pipe[1])
    
    #Running php
    os.execve("/usr/lib/cgi-bin/php5",cmd_line,env) 
    sys.exit(1)
else: #Parent process

    #Closing not needed descriptors (i_pipe was already used so it is not needed)
    os.close(i_pipe[0])
    os.close(i_pipe[1])    
    os.close(o_pipe[1])
    
    #Wait for the termination of the script
    os.waitpid(pid,0)
    
    #Reading out generated by the script
    while True:
      o=os.read(o_pipe[0],9000)
      out+=o
      if len(o)<9000:
          break
    #Closing pipe to read from the script
    os.close(o_pipe[0])

#Splitting header and content
out=out.split("\r\n\r\n")

os.write(4,out[0]+"\r\n") #Writing headers

#Sending status to weborf
f=out[0].find("Status")
if f!=-1:
    status=out[0][f+8:f+11]
    #Redirect
    if status=="303" or status=="302":
        sys.exit(33)    
    elif status=="404":#Not found, shouldn't happen because weborf verify that the file exists
        sys.exit(44)
    elif status=="400":#Error
        sys.exit(40)
    elif status=="501":#Wrong request
        sys.exit(51)

#Content not-null, sending content to weborf
if len(out)==2:
    print out[1] #Writing page

sys.exit(0)